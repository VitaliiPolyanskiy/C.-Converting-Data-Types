#include <iostream>

using namespace std;

int main()
{
	// Если в выражение входят константы и переменные разных типов, они преобразуются к одному типу. 
	// Компилятор преобразует все операнды в тип "наибольшего" операнда.
	// Синтаксис явного преобразования типов:
	//      (тип)выражение;
	// тип - тип данных, к которому приводится выражение.
	// выражение - выражение, которое необходимо привести к определенному типу.
	// Альтернативный синтаксис:
	//      тип(выражение);

	char chSymbol = 'A';
	int nValue = 5;
	float fltNumber1 = 2.5f;
	double dblNumber2 = 3.5;
	cout << char ((chSymbol / nValue) + (fltNumber1 / dblNumber2) - (fltNumber1 + nValue));

	// Преобразование типов бывает явное и неявное.
	// Явное - программист явно указывает преобразование типа данных.
	// Неявное - преобразование типов данных происходит без участия программиста.

	// Синтаксис явного приведения типов:
	//      (тип) выражение;
	// тип - любой допустимый тип данных.
	// выражение - выражение, которое необходимо преобразовать к определенному типу.
	int nInteger = 5;
	float fltNumber;
	fltNumber = (float)nInteger / 2;

	cout << "\nfltNumber = " << fltNumber << endl;

	// В приведенном ниже примере сработает неявное преобразование типов. Литерал 3.5 будет неявно 
	// приведен к типу переменной nRadius, то есть int.
	int nRadius = 3.5;

	cout << "nRadius = " << nRadius << endl;

	// Если преобразование происходит от "меньшего" типа к "большему", то такое преобразование 
	// называется расширяющим, если наоборот, то сужающим. При сужающем преобразовании происходит 
	// потеря точности, а также возможна потеря данных, если они не помещаются в приводимый тип.

	// Сужающее преобразование типов.
	short nSmall = 1;
	int nBig = 2;

	nSmall = short(nBig);

	// Расширяющее преобразование.
	float fltSmall = 0.4f;
	double dblBig = 4.4;

	dblBig = (double)fltSmall;

	// Сужающее преобразование с изменением интерпретации внутреннего представления данных
	int a = -10;
	unsigned int b = 5;
	cout << a + b << endl;

	// Сужающее преобразование с переполнением разрядной сетки
	unsigned char s = 255;
	s += 10;
	cout << short(s) << endl;

	// Сужающее преобразование с потерей точности (данных)
	a = 7.7;
	cout << a << endl;

	return 0;
}